Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2025-08-20T14:27:19+03:00

====== Минимальная защита данных ======

Даже самый «здоровый» HDD со временем деградирует, например, может «тихо» испортится блок на диске, и какой-то файл (или его часть, но уже неважно) станет нечитаемым — это называется bit rot. Положение спасают только регулярные бэкапы, но регулярно это можно делать только на другие HDD, которые тоже могут незаметно загибаться.

Файловые системы в Linux в принципе кое-чем могут помочь. Та же ext4 не спасает от bit rot, хотя и обладает обширными возможностями журналирования.

//Журнал// в ext4 — это специальный файл “''.journal''”, которым управляет драйвер ext4. Этот файл хранится на том же диске, где и сама файловая система. В него временно записываются изменения до того, как они попадут в основную часть диска.

//Журналирование// — механизм защиты файловой системы от потери данных при сбоях питания или внезапном отключении диска ВО ВРЕМЯ ЗАПИСИ ДАННЫХ. Журналирование не заменяет бэкапы, а только гарантирует, что если с hdd произойдет сбой, то файловая система не «развалится» (каталоги не исчезнут, inodes не станут «битые»), и содержимое диска можно будет восстановить. В принципе оно помогает и просто восстановить с диска уже существующие данные после, анпример, крушения ноутбука.

У журналирования есть три режима:

* ''writeback'' (data=writeback) — журналируются только метаданные, но порядок записи данных в журнал не гарантируется. Быстро, с риском получить множество «грязных» файлов при сбое.
* ''ordered'' (data=ordered, по умолчанию) — журналируются только метаданные, то есть, структура файлов, каталоги, индексы. Сначала данные пишутся на диск, потом их метаданные — в журнал. Это защищает файловую систему от «сломанных каталогов», но не защищает сами файлы от частичной записи при сбое во время записи.
* ''journal'' (data=journal) — журналируются И данные, И метаданные. При сбое всё, что было в процессе записи, можно восстановить. Минус в том, что запись происходит медленнее, потому что данные пишутся дважды — в журнал и на диск. После чего файл успокоится на диске, метаданные о нём будут урезаны до «good enough». И если произошёл сбой в этот момент, то при следующем монтировании диска ext4 видит «неприменённые транзакции» и дописывает их на диск, доводя файловую систему до целостного состояния.

Если речь идет о простом обмене файлами, то про журналирование ext4 можно не заморачиваться даже на домашнем NAS. Если же сисадмина гарантированно подвесят за задницу при недоступности каких-то файлов на рабочем сервере, где запись новых файлов может происходить каждую минуту, тогда он или настроит журналирование в ext4 в режиме ''journal'' одной командой:

''sudo tune2fs -o journal_data_writeback /dev/sdX1''

или установит файловую систему ZFS и не забудет [[Добавить RAID-массив]]

ZFS явно делали для серверов:
* можно включить RAID-Z (проверку целостности файлов через контрольные суммы и самовосстановление данных при повреждении)
* отличное управление большими пулами данных (пул — это объединение одного или нескольких HDD в общий «резервуар» пространства; для юзеров это выглядит как один сетевой диск; внутри пула можно создавать сотни файловых систем без деления диска на разделы, и у каждой будут свои настройки: квоты, сжатие, резерв)
* cнапшоты данных (snapshot — это моментальная «фотография» состояния файловой системы в конкретный момент времени; почти не занимает место сразу после создания, потому что ZFS использует Copy-on-Write: блоки данных не копируются, пока не изменятся; если какой-то файл будет удален, снапшот всё равно хранит его в исходном виде)
* клоны данных (это снапшот, который стал отдельной файловой системой; снапшоты — «моментальный бэкап», который нельзя изменить, только восстановить, а клоны — «тестовая копия», которую можно модифицировать и использовать параллельно с родителем).
* самовосстановление (Self-healing, встроенная контрольная сумма на каждый блок, при повреждении данные автоматически восстанавливаются из реплики)
* сжатие и дедупликация данных в реальном времени (дедупликация — это когда файловая система хранит одинаковые блоки данных только один раз, даже если они встречаются в разных файлах. То есть, если у тебя два одинаковых фильма, часть данных может храниться один раз, экономя место)

Минусы, конечно же, есть: 
* очень нагружает RAM и CPU, нагрузк унужно тщательно настраивать
* ZFS надо обновлять отдельно от ядра Linux. И вообще сложнее в администрировании (можно похерить всё)
* в OMV ZFS доступна только через плагин ''openmediavault-zfs''
* нельзя перевести готовые ext4-диски в ZFS без потери данных, поэтому нужны новые диски
* для обычного домашнего NAS с фильмами это избыточная тема

Если не нужны снапшоты и дедупликация, то для хранения фильмов и резервного диска с личными файлами полностью подойдёт ext4. 

===== Регулярно копировать «личные файлы» на внешний носитель =====

''rsync -av --delete /mnt/backup/ /media/usb/backup_copy/''

===== Выполнять принудительную проверку файловой системы =====

Например, раз в квартал…

===== Включить жёсткое реагирование на ошибки HDD =====

Можно настроить автоматическое выполнение проверки состояния каждого hdd ДО его монтирования в системе (инициализация партиций), и если возникнут ошибки — диск будет инициализирован в режиме Read only; НО выполняться эта проверка будет только один раз в месяц. 

Можно, но не нужно — тут лучше целенаправленно, в уже работающем OMV отмонтировать все HDD, проверить их и примонтировать обратно. Хотеть, чтобы это происходило автоматически — это да, но если неумеючи втыкать скрипты, которые должны выполняться ДО загрузки системы, то можно попасть под перекрестный огонь зависимости запуска сервисов и появления множества ошибок при старте NAS. В лучшем случае это приведет к тому, что скрипты не будут запущены, в худшем — будет нарушен алгоритм запуска машины и там уже или что-то не запустится, или сама загрузка может быть прервана или закольцована.

К тому же, в OMV нельзя сделать «как обычно» запуск чего-то при старте через файл ''/etc/fstab'' — OMV перезаписывает его по своему усмотрению, и редактировать его напрямую не надо. Надо поднимать отдельные сервисы. И настраивать…

===== Раздел, ставший ненужным =====

	*todo Убрать-переместить весь раздел. А куда?

Можно настроить выполнение раз в два месяца перед загрузкой OMV проверку состояния HDD (тех, на которых данные на файловой системе ext4). Если какой-то из HDD ответит ошибками, тогда 
* его партиция/и будет примонтирована в режиме READ ONLY,
* на системном диске появится файл “''/run/alert_about_hdd.txt''” (далее всюду ''TMP_FILE''), в который будет записано сообщение о том, что «//[HDD ERROR] /dev/$name загружен в режиме ReadOnly//».

После каждой загрузки NAS выполняется одноразовая проверка содержимого ''TMP_FILE''. Если файл существует, его содержимое будет дописано в ''TODO_FILE'' (находится в профиле моего пользователя на NAS). После логина на NAS через SSH в консоль выводится содержимое ''TODO_FILE'', и если в нём появится сообщение «//[HDD ERROR] /dev/$name загружен в режиме ReadOnly//» — я буду знать о проблеме и приму меры.

Скрипты sh должны находиться в ''/usr/local/sbin/'' — это каталог для системных утилит и админских программы, которые требуют root-доступ. Например, скрипты для управления дисками, сетевыми интерфейсами, службами. В тот же /usr/local/bin можно положить исполняемые скрипты для обычных пользователей.

==== Поднять сервис для проверки HDD перед запуском OMV ====

Будет работать только если userspace находится на внешнем носителе [[Users:Сделать “User home directory”]] , потому что если каталог ''users'' будет на одном из внутренних hdd, этот hdd не будет размонтирован, как полагается, и будет таким образом исключен из общей проверки дисков. Останется только возможность [[Загрузить Debian Live с USB]].

=== Сделать скрипт ===

Будет запускаться из одноименного сервиса.

''sudo mcedit /usr/local/sbin/check_hdd_before_omv_mounts.sh''

{{{code: id="check_hdd" lang="sh" linenumbers="True"
#!/bin/bash

    # Скрипт проверки HDD перед монтированием OMV
    # Все сообщения записываются во временный файл /run/alert_about_hdd_readonly.txt
    # Массив found_hdds хранит все найденные HDD

set -e

TMP_FILE="/run/alert_about_hdd_readonly.txt"

    # объявление функции
found_hdds=()

#  ---- Функция отчёта ----
report_found_hdds() {
    local -n hdds=$1   # передаём массив по ссылке
    if [ ${#hdds[@]} -gt 0 ]; then
        {
            echo "# Отчёт о найденных HDD"
            echo "[INFO] Найденные HDD с ext4:"
            for hdd in "${hdds[@]}"; do
                echo "  $hdd"
            done
        } >> "$TMP_FILE"
    fi
}

    # сделать файл для контроля даты запуска скрипта
STATE_FILE="/root/timer_check_hdd_before_omv_mounts.txt"

month=$(date +%m)
current_run="$(date +%Y-%m)"

    # Этот скрипт будет запускаться только в чётные месяцы (раз в два месяца)
if (( month % 2 != 0 )); then
    # echo "[INFO] Пропускаем — месяц нечётный ($month)" >> "$TMP_FILE"
    exit 0
fi

    # Если уже запускали в этом месяце — выйти. Если нет — выполнить один раз.
if [[ -f "$STATE_FILE" ]] && grep -q "^$current_run$" "$STATE_FILE"; then
    # echo "[INFO] Уже выполнялся в этом месяце ($current_run)" >> "$TMP_FILE"
    exit 0
fi

# Перебираем все устройства
while read -r name fstype rota label; do
    # Только HDD ext4
    if [ "$fstype" != "ext4" ] || [ "$rota" != "1" ]; then
        continue
    fi

    # Исключаем Debian Live флэшку
    if [[ "$label" == d-live* ]]; then
        continue
    fi

    part="/dev/$name"
    found_hdds+=("$part")

    # Проверка состояния раздела
    fsck -n -f "$part" >/tmp/fsck_check.log 2>&1

    if grep -q "clean=0" /tmp/fsck_check.log; then
        echo "[HDD ERROR] $part загружен в режиме ReadOnly" >> "$TMP_FILE"
    fi
done < <(lsblk -nr -o NAME,FSTYPE,ROTA,LABEL)

echo "$current_run" > "$STATE_FILE"

    # Вызов функции отчёта
report_found_hdds found_hdds

}}}

Сделать его исполняемым

''sudo chmod +x /usr/local/sbin/check_hdd_before_omv_mounts.sh''

=== Сделать сервис ===

Выполняется один раз при включении компьютера (Type=oneshot) до того, как будут инициализированы партиции на дисках (Before=local-fs.target).

''sudo mcedit /etc/systemd/system/check_hdd_before_omv_mounts.service''

{{{code: id="hdd_service" lang="sh" linenumbers="True"
[Unit]
Description=Check HDD before OMV mounts
DefaultDependencies=no
Before=local-fs.target

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/check_hdd_before_omv_mounts.sh

[Install]
WantedBy=multi-user.target

}}}

Активировать:

'''
sudo systemctl daemon-reload
sudo systemctl enable check_hdd_before_omv_mounts.service
sudo systemctl start check_hdd_before_omv_mounts.service
sudo systemctl status check_hdd_before_omv_mounts.service
'''

В ответ ожидаем что-то вроде 

''Loaded:'' __''loaded''__ ''(/etc/systemd/system/check_hdd_before_omv_mounts.service;'' __''enabled''__''; preset:'' __''enabled''__'')''
''Active:'' __''inactive''__ ''(dead) since Mon 2025-08-25 04:43:11 EEST; 4s ago''

Юнит корректно деактивировался после выполнения (inactive (dead)). Он же одноразовый.

==== Поднять сервис с таймером для check_hdd_before_omv_mounts ====

''sudo mcedit /etc/systemd/system/check_hdd_before_omv_mounts.timer''

{{{code: id="timer" lang="sh" linenumbers="True"
[Unit]
Description=Run OMV HDD check monthly

[Timer]
Unit=check_hdd_before_omv_mounts.service
OnCalendar=*-01-00:00:00/2
Persistent=true

[Install]
WantedBy=timers.target

}}}

Активация

'''
sudo systemctl daemon-reload
sudo systemctl enable check_hdd_before_omv_mounts.timer
sudo systemctl start check_hdd_before_omv_mounts.timer
sudo systemctl status check_hdd_before_omv_mounts.timer
'''

Ожидаемый ответ: ''Active: active (waiting)''

==== Поднять сервис для алертов про R/O диск ====

=== Сделать скрипт ===

''sudo mcedit /usr/local/sbin/check_hdd_get_alert_about_hdd_readonly.sh''

{{{code: id="qwe" lang="sh" linenumbers="True"
#!/bin/bash

    # После инициализации системы надо проверить наличие TMP_FILE
    # Если он есть — дописать его содержимое в TODO_FILE

    # TMP_FILE создан на временной файловой системе и исчезнет после выключения NAS

TMP_FILE="/run/alert_about_hdd_readonly.txt"
TODO_FILE="/user/todo.txt"

    # дежурная проверка на наличие TMP_FILE (надеемся, что его нет)
if [ -s "$TMP_FILE" ]; then
    cat "$TMP_FILE" >> "$TODO_FILE"
fi

}}}

''sudo chmod +x /usr/local/sbin/check_hdd_get_alert_about_hdd_readonly.sh''

=== Сделать сервис ===

Сервис выполняется один раз после инициализации всех дисков.

'''
sudo mcedit /etc/systemd/system/check_hdd_get_alert_about_hdd_readonly.service
'''

{{{code: id="ds" lang="sh" linenumbers="True"
[Unit] 
Description=Alert user if there is a message in file /run/message_about_hdd.txt
After=local-fs.target

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/check_hdd_get_alert_about_hdd_readonly.sh

[Install]
WantedBy=multi-user.target

}}}

'''
sudo systemctl daemon-reload
sudo systemctl enable check_hdd_get_alert_about_hdd_readonly.service
sudo systemctl start check_hdd_get_alert_about_hdd_readonly.service
sudo systemctl status check_hdd_get_alert_about_hdd_readonly.service
'''

===== Удалить (любой) сервис =====

На всякий случай

'''
sudo systemctl stop abc.service
sudo systemctl disable abc.service
sudo systemctl status abc.service
rm /etc/systemd/system/abc.service
'''

Также см. [[Приложения:Запуск скриптов при загрузке системы]]
