Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2025-08-20T14:27:19+03:00

====== Минимальная защита данных ======

Даже самый «здоровый» HDD со временем деградирует, например, может «тихо» испортится блок на диске, и какой-то файл (или его часть, но уже неважно) станет нечитаемым — это называется bit rot. Положение спасают только регулярные бэкапы, но регулярно это можно делать только на другие HDD, которые тоже могут незаметно загибаться.

Файловые системы в Linux в принципе кое-чем могут помочь. Та же ext4 не спасает от bit rot, хотя и обладает обширными возможностями журналирования.

//Журнал// в ext4 — это специальный файл “''.journal''”, которым управляет драйвер ext4. Этот файл хранится на том же диске, где и сама файловая система. В него временно записываются изменения до того, как они попадут в основную часть диска.

//Журналирование// — механизм защиты файловой системы от потери данных при сбоях питания или внезапном отключении диска ВО ВРЕМЯ ЗАПИСИ ДАННЫХ. Журналирование не заменяет бэкапы, а только гарантирует, что если с hdd произойдет сбой, то файловая система не «развалится» (каталоги не исчезнут, inodes не станут «битые»), и содержимое диска можно будет восстановить. В принципе оно помогает и просто восстановить с диска уже существующие данные после, анпример, крушения ноутбука.

У журналирования есть три режима:

* ''writeback'' (data=writeback) — журналируются только метаданные, но порядок записи данных в журнал не гарантируется. Быстро, с риском получить множество «грязных» файлов при сбое.
* ''ordered'' (data=ordered, по умолчанию) — журналируются только метаданные, то есть, структура файлов, каталоги, индексы. Сначала данные пишутся на диск, потом их метаданные — в журнал. Это защищает файловую систему от «сломанных каталогов», но не защищает сами файлы от частичной записи при сбое во время записи.
* ''journal'' (data=journal) — журналируются И данные, И метаданные. При сбое всё, что было в процессе записи, можно восстановить. Минус в том, что запись происходит медленнее, потому что данные пишутся дважды — в журнал и на диск. После чего файл успокоится на диске, метаданные о нём будут урезаны до «good enough». И если произошёл сбой в этот момент, то при следующем монтировании диска ext4 видит «неприменённые транзакции» и дописывает их на диск, доводя файловую систему до целостного состояния.

Если речь идет о простом обмене файлами, то про журналирование ext4 можно не заморачиваться даже на домашнем NAS. Если же сисадмина гарантированно подвесят за задницу при недоступности каких-то файлов на рабочем сервере, где запись новых файлов может происходить каждую минуту, тогда он или настроит журналирование в ext4 в режиме ''journal'' одной командой:

''sudo tune2fs -o journal_data_writeback /dev/sdX1''

или установит файловую систему ZFS и не забудет [[Добавить RAID-массив]]

ZFS явно делали для серверов:
* можно включить RAID-Z (проверку целостности файлов через контрольные суммы и самовосстановление данных при повреждении)
* отличное управление большими пулами данных (пул — это объединение одного или нескольких HDD в общий «резервуар» пространства; для юзеров это выглядит как один сетевой диск; внутри пула можно создавать сотни файловых систем без деления диска на разделы, и у каждой будут свои настройки: квоты, сжатие, резерв)
* cнапшоты данных (snapshot — это моментальная «фотография» состояния файловой системы в конкретный момент времени; почти не занимает место сразу после создания, потому что ZFS использует Copy-on-Write: блоки данных не копируются, пока не изменятся; если какой-то файл будет удален, снапшот всё равно хранит его в исходном виде)
* клоны данных (это снапшот, который стал отдельной файловой системой; снапшоты — «моментальный бэкап», который нельзя изменить, только восстановить, а клоны — «тестовая копия», которую можно модифицировать и использовать параллельно с родителем).
* самовосстановление (Self-healing, встроенная контрольная сумма на каждый блок, при повреждении данные автоматически восстанавливаются из реплики)
* сжатие и дедупликация данных в реальном времени (дедупликация — это когда файловая система хранит одинаковые блоки данных только один раз, даже если они встречаются в разных файлах. То есть, если у тебя два одинаковых фильма, часть данных может храниться один раз, экономя место)

Минусы, конечно же, есть: 
* очень нагружает RAM и CPU, нагрузк унужно тщательно настраивать
* ZFS надо обновлять отдельно от ядра Linux. И вообще сложнее в администрировании (можно похерить всё)
* в OMV ZFS доступна только через плагин ''openmediavault-zfs''
* нельзя перевести готовые ext4-диски в ZFS без потери данных, поэтому нужны новые диски
* для обычного домашнего NAS с фильмами это избыточная тема

Если не нужны снапшоты и дедупликация, то для хранения фильмов и резервного диска с личными файлами полностью подойдёт ext4. 

В любом случае вот что обязательно надо делать регулярно:

===== Включить жёсткое реагирование на ошибки HDD =====

Можно настроить автоматическое выполнение проверки состояния каждого hdd ДО его монтирования в системе (инициализация партиций), и если возникнут ошибки — диск будет инициализирован в режиме Read only; НО выполняться эта проверка будет только один раз в месяц. 

Но в OMV это нельзя сделать «как обычно» через файл ''/etc/fstab'' — OMV перезаписывает его по своему усмотрению, и редактировать его напрямую не надо. 



Вот как можно сделать:


''lsblk -f''

Отсюда взять UUID для каждого HDD в NAS.

Настроить tune2fs для интервала автопроверки — раз в месяц (1m) без учета количества монтирований:

''sudo tune2fs -i 1m -c 0'' __''HDD_UUID''__

Выполнить эту команду для каждого HDD.

''sudo mcedit /etc/fstab''

__''HDD_UUID''__=1234-ABCD /mnt/backup  ext4  defaults,errors=remount-ro  0  2

Здесь:
* defaults = набор стандартных опций (варианты — rw, suid, dev, exec, auto, nouser, async).
* errors=remount-ro = если в ФС возникнет ошибка, смонтировать её в режиме read-only (только чтение), чтобы не усугубить проблему.
* 0 — участвует ли этот раздел в dump (резервное копирование старой утилитой dump). Обычно 0 (не участвует). 0 нет, 1 да.
* 2 — порядок проверки fsck при загрузке:
	* 0 = не проверять.
	* 1 = корневой раздел (/), проверяется первым.
	* 2 = все остальные, проверяются после корневого; на скорость загрузки это не влияет.







опцию errors=remount-ro, чтобы при ошибках диск автоматически переходил в режим «только чтение», но при этом выполнять эту операцию  
прописать в fstab 



загрузиться с флэшки с Debian Live.
на диске, с которого загружается OMV, найти /etc/fstab
добавить для каждого hdd инструкцию “''errors=remount-ro  0 2''”. Пример:

'''
/dev/sdX1  /mnt/backup  ext4  defaults,errors=remount-ro  0 2
'''

Здесь:
* defaults = набор стандартных опций (rw, suid, dev, exec, auto, nouser, async).
* errors=remount-ro = если в ФС возникнет ошибка, смонтировать её в режиме read-only (только чтение), чтобы не усугубить проблему.
* 0 — участвует ли этот раздел в dump (резервное копирование старой утилитой dump). Обычно 0 (не участвует). 0 нет, 1 да.
* 2 — порядок проверки fsck при загрузке:
	* 0 = не проверять.
	* 1 = корневой раздел (/), проверяется первым.
	* 2 = все остальные, проверяются после корневого.

Вместо ''/dev/sdX1'' лучше указывать UUID, чтобы избежать вероятности сбоя при смене дисков.

Выйти и загрузить OMV в штатном режиме.


==== Как это всё проверять ====

Сделать файл 

''mcedit check_hdd_read_only.sh''

Вставить текст

{{{code: id="check_hdd_read_only.sh" lang="sh" linenumbers="True"
!/bin/bash

    # После каждой загрузки NAS происходит инициализация партиций на всех
    # HDD. Раз в месяц происходит автоматическая проверка состояния дисков.
    # Если обнаружен сбой, партиции на HDD будут инициализированы в режиме
    # ReadOnly. 

    # Этот скрипт выполняется после каждой загрузки NAS. Он быстро
    # проверяет состояние всех дисков. Если какой-то из них загружен в RO,
    # сообщение об этом записывается в файл todo.txt в профиле юзера tower и
    # дежурно выводится в консоль при каждом подключении по ssh и прочитывании
    # содержимого файла .bashrc

    # Файл todo
TODO_FILE="/srv/dev-disk-by-uuid-9b3771d9-c454-4acd-b683-568da8815820/users/tower/todo.txt"

    # Проверяем опции монтирования всех HDD/SSD

    # findmnt выводит (HUGE!) таблицу блочных устройств с указанными колонками:
    # имя, точка монтирования, RO, тип ФС и размер.

    # awk ищет все HDD (только вращающиеся диски с параметром ROTA=1, это шестой номер по счету, поэтому алерт на $6==1),
    # и если у диска в списке найденных есть параметр RO (3==1), то к этой строке приписывается маркер <-- READ-ONLY

    # | while read line; do … done — перебирает каждую полученную строку.

    # если строка помечена <-- READ-ONLY, выполняем запись о ней в TODO_FILE

lsblk -o NAME,MOUNTPOINT,RO,FSTYPE,SIZE,ROTA \
| awk '$6==1 {print $0, ($3==1 ? "<-- READ-ONLY" : "")}' \
| while read -r line; do
    if echo "$line" | grep -q "<-- READ-ONLY"; then
        echo -e "\n ВНИМАНИЕ! HDD загружен в режиме READ-ONLY:\n $line \n" >> "$TODO_FILE"
    fi
done

}}}

Сохранить, выйти.  И сделать его исполняемым

''sudo chmod +x check_hdd_read_only.sh''

Открыть файл (если файла нет — надо создать):

'''
sudo mcedit /etc/rc.local
'''

Указать полный путь к скрипту (можно выявить по ''pwd''), и он будет выполняться при каждой загрузке системы

{{{code: id="rc.local" lang="sh" linenumbers="True"
#!/bin/bash

# Проверка HDD на read-only после загрузки OMV
/full/path/check_hdd_read_only.sh

exit 0

}}}

Обязательно последней строкой указать ''exit 0''

Сделать файл исполняемым:

''sudo chmod +x /etc/rc.local''

===== Регулярно копировать «личные файлы» на внешний носитель =====

''rsync -av --delete /mnt/backup/ /media/usb/backup_copy/''

===== Выполнять принудительную проверку файловой системы =====

Например, раз в квартал…

