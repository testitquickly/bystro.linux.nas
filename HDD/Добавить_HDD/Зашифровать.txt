Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-01-31T16:50:18+02:00

====== Зашифровать ======

===== Теория =====

Шифровать диск надо ДО появления на нём данных, потому что надо с нуля создать на нём партицию-контейнер.

Непременно надо шифровать криптокошельки и прочую бухгалтерию, но для такого добра шифровать весь диск не нужно, оно много места не занимает и может лежать в криптоконтейнере типа VeraCrypt. А ещё можно такие файлы зашифровывать через ключи gpg, тогда и криптоконтейнер для них не собо нужен, но если таких файлов много, юзеры начнут глубинно задалбываться необходимостью постоянно открывать их через пароли. Можно это всё комбинировать: особо секретные файлы надо шифровать ключом gpg и держать их на зашифрованном HDD в криптоконтейнере…

Важно понимать:

* шифрование требует повышенного расхода ресурсов CPU
* надо шифровать только то, что действительно //надо// шифровать — очень личные файлы, которые важно защитить или просто держать закрытыми. Например, на случай внезапной болезни/смерти их владельца
* зашифрованность диска обломит того, кто вытащит/украдёт диск из NAS и захочет его прочитать, но не остановит того, кто атакует компьютер через сеть, потому что после успешного логина в OMV доступны все примонтированные диски, в том числе и зашифрованные. Есть резон монтировать зашифрованные партиции только при необходимости и ненадолго
* шифрование HDD не остановит порядочного гражданина, который случайно захочет прогреть свой утюг на незашифрованной заднице счастливого владельца NAS с надёжно зашифрованными дисками
* если файлы, которые надо зашифровать, находятся одновременно в одной комнате и на ноутбуке, и на зашифрованной партиции в NAS, и в комнату зайдут злые акабы и заберут сразу всю технику (и уже не вернут), то смысла держать на NAS зашифрованную партицию нет. В таком случае надо уже и на ноутбуке держать файлы в криптоконтейнере, который настроен на «захлопнул крышку ноута — контейнер закрылся»
* шифрование делает данные на HDD полностью случайными с точки зрения восстановления. Если зашифрованный диск крякнется, восстановить данные без ключа/пароля невозможно, а для этого придётся передать незнакомому человеку в незнакомый сервис секретный ключ и надеяться на то, что никто не будет открывать восстановленный контент, не передаст его кому-нибудь, не выложит в сеть и не запаролит с намёком на выкуп

==== Скорость ====

Скорость обращения к зашифрованному диску в принцие будет //вдвое// меньше обычного. При шифровании растёт нагрузка на CPU, что особенно заметно на NAS устаревшего поколения с уже слабыми двухядерными процессорами без отдельного модуля шифрования AES (Advanced Encryption Standard, основной и самый распространённый алгоритм симметричного шифрования данных). На старых компьютерах разумно использовать ослабленное шифрование.

==== Долговечность ====

Шифрование SSD практически не снижает срок службы диска, если 

* это современный SSD с нормальным TBW (Total Bytes Written, характеристика SSD которая указывает сколько данных можно всего записать на диск, прежде чем он официально исчерпает свой ресурс), 
* и TRIM включён (discard работает) 
* и в swap не записываются гигабайты данных каждый час. 

В случае сбоя восстановление данные с SSD с активным TRIM без резервной копии практически невозможно — удалённые блоки физически уничтожаются. Нужен регулярный бэкап бэкапа.

Шифрование на HDD на его долговечность не влияет, потому что у HDD нет ограниченного ресурса TBW, как у SSD.

Любой диск может внезапно умереть, не оставив после себя наследства. Восстанавливать записи с зашифрованного диска можно, но иногда это отдельная олимпиада, участвовать в которой никто не захочет.

===== Подготовить окружение =====

==== Установить cryptsetup ====

И на ноуте, и на NAS:

''sudo apt update && sudo apt install cryptsetup''

==== Установить в OMV плагин LUKS ====

Не факт, что им будем пользоваться, но он не помешает.

''System > Plugins''

Найти в поиске плагин //openmediavault-luksencryption,// установить.

В разделе Storage появится новый пункт “Encryption”.

==== Приготовить HDD ====

Вставить диск, который надо зашифровать.

Он может быть или полностью пустым, или с отдельной пустой партицией, для которой будет сделано шифрование. Второй случай несколько противоречит идеологии NAS, которая подразумевает, что диски иногда надо заменять, и это проще делать целиком, поэтому надо придерживаться подхода «один диск, одна партиция», но и только.

Далее 
1. будет создан криптоконтейнер (LUKS-раздел) на свободном разделе HDD
2. в этом криптоконтейнере будет создана партиция (логически выделенный кусок физического диска, который ОС воспринимает как отдельное устройство) 
3. на этой партиции будет создана файловая система ''ext4''

===== Создать зашифрованную партицию =====

В норме это должно быть сделано через плагин OMV, но не факт, что получится. Иногда в форме создания зашифрованного контейнера в поле //Device// ничего не отображается.

1. ''Storage > Encryption > [+ Create]''
2. в поле Device выбрать вставленный диск.
3. Указать //encryption key// поядрённее. Не потерять его и не ошибиться при записи, потому что без ключа зашифрованные данные восстановлению не подлежат
4. [Create / Apply / Yes]

Если надо зашифровать несколько дисков — повторить для каждого последовательно.

Предпочтительный способ далее — вручную.

==== Создать раздел для криптоконтейнера ====

Посмотреть все диски в системе:

''sudo fdisk -l''

Предположим, что нужный диск отображается так:

''Disk /dev/sdb: 5,46 TiB, 6001175126016 bytes, 11721045168 sectors''
''Disk model: WDC WD60EFAX-68J''
''Units: sectors of 1 * 512 = 512 bytes''
''Sector size (logical/physical): 512 bytes / 4096 bytes''
''I/O size (minimum/optimal): 4096 bytes / 4096 bytes''
''Disklabel type: gpt''
''Disk identifier: 6488AC97-86B8-4CEA-8895-7760833B7915''

''Device     Start        End    Sectors  Size Type''
''/dev/sdb1   2048 7577749503 7577747456  3,5T Linux filesystem''

Всего секторов на диске: ''11 721 045 168''

Раздел ''/dev/sdb1'' начинается с самого начала (на ''2048'') и заканчивается на секторе ''75 77 749 503''

''11 721 045 168 - 75 77 749 503 = 4 143 295 648'' секторов ''× 512 Б ≈ 2 ТиБ'' неразмеченного пространства //в конце// диска.

=== Создать новый раздел ===

Если партиции на диске уже примонтированы в систему — отмонтировать их.

И трижды убедиться в том, что на диске нет важных данных, потому что даже если действовать осторожно, всё может запороться в любой момент. Вообще, хорошо делать шифрованные разделы на HDD до того, как он попадёт в NAS.

Открыть интерактивный диалог в fdisk на HDD /sdb/:

''sudo fdisk /dev/sdb''

Аккуратно пошагово выполнить эти команды:

1. ''n''			# новый раздел
2. <''Enter''>	# номер по умолчанию, начинается с 2, потому что sdb1 уже занят
3. <''Enter''>	# начало по умолчанию
4. <''Enter''>	# до конца свободного места
5. ''t''			# изменить тип раздела, чтобы сразу создать зашифрованный
6. <''Enter''>	# выбранный раздел
7. ''30''		# position type — код "Linux LUKS" (0x30). Это ещё не контейнер, это только запись в таблице разделов
8. ''w''			# записать изменения и выйти

Партиция /dev/sdb2/ создана. Проверить (все диски):

''sudo fdisk -l''

==== Создать зашифрованный контейнер ====

На зашифрованном разделе надо создать контейнер данных, он же «LUKS-раздел». Имя контейнера — любое, было бы понятным, разумно заранее задать его созвучным с лейблом партиции (будет создан на следующем шаге).

Также для него надо придумать пароль сложнее чем ''1234'' (год крестового похода против штедингов).

Но сперва надо выбрать алгоритм шифрования. Их два:

* AES-XTS (XEX-based Tweaked CodeBook with ciphertext Stealing) — даёт максимальную безопасность, но сильно нагружает CPU. Он специально разработан для шифрования дисков, и добавляет «твит» (уникальное смещение) для каждого сектора, чтобы одинаковые данные на разных позициях на диске шифровались по-разному, что защищает от анализа структуры диска, например, нельзя увидеть, какие блоки одинаковые. Для этого используются два ключа AES — для данных и для твита, из-за этого CPU нужно выполнять в два раза больше вычислений.
* AES-CBC (Cipher Block Chaining) — уже классический режим шифрования блоков, был разработан давно, когда у CPU в принципе не было  аппаратного AES. Каждый блок данных шифруется с учётом предыдущего (цепочка блоков). Уязвим для атак на повторяющиеся шаблоны данных в типичных сценариях работы с дисками, например, два одинаковых блока данных на диске → одинаковое шифротекстовое значение при одинаковом векторе инициализации (IV, Initialization Vector) — это начальное случайное значение, которое добавляют к данным перед первым шагом шифрования. Можно использовать вместе с ESSIV (Encrypted Salt-Sector Initialization Vector) — это IV со специальной защитой, «зашифрованный солью вектор инициализации по номеру сектора». Алгоритм CBC чувствителен к повреждению блоков данных на HDD — при ошибке расшифровки одного блока страдает весь следующий фрагмент.

=== Для слабого CPU ===

Сперва рассмотреть возможность апгрейд железа. Если такой возможности нет, то выбираем AES-CBC типа essiv с минимальным ключом на 128 бит, как компромисс между безопасностью и скоростью работы

Установка LUKS AES в режиме CBS с eesiv с ключом на 128 бит: на партицию ''/dev/sdb2'':

''sudo cryptsetup luksFormat \''
''--type luks2 \''
''--cipher aes-cbc-essiv:sha256 --key-size 128 \''
''--key-size 128 \''
''--hash sha256 \''
''/dev/sdb2''

Ввести заглавными буквами ''YES'' и указать придуманный для этого пароль. В теории, пароль должен быть НЕВЕРОЯТНО неоднозначным, трудным для запоминания и, соответственно, взламывания.

Сохранить этот пароль любым самым надёжным способом, обязательно — вне NAS. Можно в каком-то менеджере паролей вроде KeePassXC, пароли оттуда можно копировать и вставлять в консоль через ''Ctrl+Shift+V''.

Если CPU современный и более-менее фурычит, или если у него хотя бы есть отдельный модуль AES, можно использовать AES-XTS типа plain64 с минимальным ключом на 256 бит. Ключ на 128 бит у XTS невозможен, по факту используется два ключа по 128 бит (128 + 128 = 256).

=== Для современного CPU ===

Пример установки LUKS AES в режиме XTS типа plain64 с ключом на 256 бит на партицию ''/dev/sda1'':

''sudo cryptsetup luksFormat \''
  ''--type luks2 \''
  ''--cipher aes-xts-plain64 \''
  ''--key-size 256 \''
  ''--hash sha256 \''
  ''/dev/sdb2''

Указать уже придуманный пароль. Ждать, пока откроется.

===== Найти существующий зашифрованный раздел =====

''sudo lsblk''

Пример ответа:

''NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS''
''sdb      8:0    0   5,5T  0 disk'' 
''├─sdb1   8:1    0   3,5T  0 part /export/images''
''│                                /export/backup''
''│                                /srv/dev-disk-by-uuid-1a456221-1a67-460f-b36e-aff8f6e847a5''
''└─sdb2   8:2    0     2T  0 part'' 

Эти диски размечал я, поэтому я уже знаю, что зашифрованный раздел находится на ''/dev/sdb2''. Также можно выяснить этот адрес в OMV > Storage > Encryption > Device…

Но адрес типа ''/dev/sdb2'' всегда временный, при каких-то операциях стирания/создания партиций или после вынимания дисков из NAS, или просто после какой-то очередной перезагрузки нумерация дисков может поменяться. Лучше ориентироваться на постоянный PARTUUID (Partition Table Level ID). Ещё есть UUID (Universally Unique Identifier), но он тоже иногда меняется.

Узнать partuuid для ''/dev/sdb2'':

''sudo blkid /dev/sdb2''

Пример ответа:

'''
/dev/sdb2: UUID="dbff005f-634a-4abe-af69-5094fa0a5de9" TYPE="crypto_LUKS" PARTUUID="f8c7131b-0d62-9445-9095-cdd773341055"
'''

Отныне в скриптах обращаться к этому разделу через его UUID следующим образом:

''/dev/disk/by-partuuid/f8c7131b-0d62-9445-9095-cdd773341055''

===== Открыть зашифрованный контейнер =====

На разделе ''/dev/sdb2'', в котором находится LUKS-зашифрованный контейнер, будет создано новое блочное устройство (диск без файлов), которому будет присвоено название “''enc_wd_red_6tb''”. Название произвольное, хоть “''pismo_onegina_tatyane''” — по нему будет удобно ориентироваться.

''sudo cryptsetup open /dev/disk/by-partuuid/f8c7131b-0d62-9445-9095-cdd773341055 enc_wd_red_6tb''

Указать ранее придуманный пароль.

==== Проверить, какие контейнеры открыты ====

В норме одновременно должен быть только один криптоконтейнер. Есть вероятность, что какой-то контейнер будет открыт одновременно несколько раз под разными именами. Потенциально это может привести к порче данных, поэтому следим за тем, чтобы такого не было.

Зашифрованные партиции определяются в системе как устройства с особым типом имен. Обращения к ним происходит через ''/dev/mapper/'':

''ls -l /dev/mapper''

Если нет открытых криптоконтейнеров:

''итого 0''
''crw------- 1 root root 10, 236 ноя  1 10:39 control''

Если какой-нибудь криптоконтейнер открыт:

''итого 0''
''crw------- 1 root root 10, 236 ноя  1 10:39 control''
''lrwxrwxrwx 1 root root       7 ноя  1 11:09 enc_wd_red_6tb -> ../dm-0''

Когда будут добавлены новые контейнеры, цифра порядка в имени партиции будет увеличена.

''/dev/dm-0''
''/dev/dm-1''
''…''

===== Закрыть открытый контейнер =====

Тут уже надо обращаться к нему по имени, которое он получил при открытии:

''sudo cryptsetup close enc_wd_red_6tb''

Криптоконтейнер можно открывать или под одним и тем же именем, или всегда под разными именами, например, с добавлением timestamp. Имя может быть человекочитаемым или цифробуквенной абракадаброй. Не факт, что всё это нужно, но это возможно.

===== Создать внутри открытого контейнера новую файловую систему =====

Тут осторожно, это нужно только для создания новой файловой системы (ext4) на зашифрованной партиции на HDD. Если там уже есть партиция с данными, все данные будут уничтожены.

''sudo mkfs.ext4 /dev/mapper/enc_wd_red_6tb''

Можно при создании файловой системы на партиции прописать ей имя (см. [[Прописать label]]):

''sudo mkfs.ext4 /dev/mapper/enc_wd_red_6tb -L YOUR_LABEL''

Лейбл произвольный, может быть таким же, как и название контейнера — только бы не запутывало. 

Проверить:

''sudo lsblk -f''

Ожидаемый результат:

''sdb''                                                                         
''├─sdb1''
''│    ext4   1.0         1a456221-1a67-460f-b36e-aff8f6e847a5''
''└─sdb2''
	 ''crypto 2           dbff005f-634a-4abe-af69-5094fa0a5de9''
  ''└─enc_wd_red_6tb''
	 ''ext4   1.0         30c9bd69-db3b-4ce6-a317-570b293c0891''

Ок, есть зашифрованная партиция с uuid ''30c9bd69…''

==== Переписать label ====

Если вдруг понадобится/захочется, то надо учесть, что label создаётся для файловой системы, а не для зашифрованного раздела, внутри которого находится файловая система. Поэтому надо сперва открыть зашифрованный раздел, и если в нём есть файловая система (например, ''ext4''), тогда ему можно прописать лэйбл.

Посмотреть, какая файловая система находится внутри криптоконтейнера, который открыть на устройстве ''/dev/dm-0'':

''sudo blkid /dev/dm-0''

Пример ответа:

''/dev/dm-0: UUID="30c9bd69-db3b-4ce6-a317-570b293c0891" BLOCK_SIZE="4096" TYPE="ext4"''

Ок, есть файловая система, тип ext4.

Можно дать ей лэйбл, отмонтировать её при этом необязательно:

''sudo e2label /dev/dm-0 YOUR_LABEL''

Проверить:

''sudo e2label /dev/dm-0''

===== Примонтировать зашифрованную партицию =====

По-умолчанию запись на диск с зашифрованной партицией будет доступна для записи только для ''root''. Если нужен доступ других юзеров — из-под root поменять права доступа и, если надо, то и владельца.

При обслуживании зашифрованных партиций CPU работает под постоянно повышенной нагрузкой. Если NAS старенький и нет нужды постоянно держать открытым криптоконтейнер, лучше не монтировать зашифрованные партиции при загрузке OMV — подключил при необходимости, отработал, отключил.
 
==== …при старте OMV ====

Автоматически примонтировать её не получится.

Надо сперва зайти в ''Storage > Encryption'' и вручную разлочить нужный криптоконтейнер (их может быть одновременно много), указав соответствующий пароль.

Когда он разлочен (указать пароль), она появится в системе как свободная партиция, которую можно примонтировать: ''File Systems > Mount an existing file system''. 

Доступная для монтирования файловая система с зашифрованной партиции будет определяться как ''/dev/dm-0''. После её монтирования в каталоге /srv/ появится новый каталог типа ///srv/dev-disk-by-uuid-1a45622…// с файлами. 

На основе доступных каталогов на партиции из криптоконтейнера можно сделать Shared Folders. Их содержимое будет доступно или до тех пор, пока открыт криптоконтейнер, или до первой перезагрузки NAS.

После перезагрузки система будет просыпаться дольше обычного — в ней был создан Mount point, который надо обслужить, а партиция для него недоступна — мы знаем, что она залочена, но в целом эффект такой же, как будто диск из выключенной системы выдернули, не размонтировав.

==== …вручную (ssh) ====

В этом случае OMV при своей иницализации не будет «видеть» зашифрованную партицию на HDD и не будет её автоматически монтировать. И если NAS будет успешно взломан через сеть, зашифрованные данные останутся закрытыми. 

=== Сделать каталог для монтирования ===

Каталог, в который будем монтировать зашифрованную партицию, надо сделать заранее. Место и название не имеет значения, хоть в /mnt/, хоть в профиле юзера, хоть каждый раз создавать его заново в ''/tmp'', всё равно он нужен ненадолго. 

Можно и в ''/srv/'', в общем месте монтирования всех HDD. И назвать можно откровенно:

''/srv/dev-disk-by-uuid-enc-wd_red_6tb''

А можно завуалировать:

''/srv/dev-disk-by-uuid-006tbhdd-r34f-q3r4-6b78-pc45fb2ks921''

От взлома или горячего утюга это всё не спасает, но на фоне остальных будет смотреться выигрышно, первым в списке. 

Если точек монтирования будет несколько, то разумно сделать отдельный каталог для каждой.

=== Открыть криптоконтейнер ===

Сперва проверить, не открыт ли он уже. Поверять это надо всегда.

'''
ls /dev/mapper
'''

Если ни один не открыт, в ответе будет только слово:

''control''

Открыть зашифрованный контейнер который находится на HDD на разделе ''/dev/sdb2'' (это надо знать заранее), к которому мы обратимся через его UUID (который тоже надо выяснить заранее) и я хочу назвать его “''enc_wd_red_6tb''”.

''sudo cryptsetup open /dev/disk/by-partuuid/f8c7131b-0d62-9445-9095-cdd773341055 enc_wd_red_6tb''

Указать ранее придуманный пароль. В системе появится новое «блочное устройство» — партиция с файлами:

''/dev/mapper/enc_wd_red_6tb'' 

== А можно не вводить каждый раз пароль? ==

Да. 

Можно сделать [[+Ключ-файл]] вроде //enc_wd_red_6tb.key;// он даст возможность открывать криптоконтейнер через скрипт монтирования с ноутбука просто своим наличием. Держать его можно и на ноуте, и на флэшке. 

Надо привыкнуть не забывать ВСЕГДА снимать монтирование зашифрованной партиции на NAS и закрывать криптоконтейнер после использования.

=== Примонтировать партицию из криптоконтейнера ===

В каталог, который был ранее создан, примонтировать файловую систему с только что открытого «блочного устройства»:

''sudo mount /dev/mapper/enc_wd_red_6tb /srv/dev-disk-by-uuid-006tbhdd-r34f-q3r4-6b78-pc45fb2ks921''

Если всё ок, то в каталоге ''/srv/dev-disk-by-uuid-006tbhdd-…'' появляются файлы.

== Shared folders на зашифрованную партицию ==

Можно сделать, но:

* это в принципе не надо, если она не будет открыта постоянно; после перезагрузки OMV увидит точки монтирования, и будет какое-то время искать отстутствующую партицию с файлами — а их нет, криптоконтейнер закрыт, и этот ненужный поиск неподключенных партиций заметно затормозит старт NAS
* это необязательно, если надо только изредка закидывать туда файлы с ноута, а это делается через [[Бэкапы:RSync]]
* это вообще не нужно, если в зашифрованную зону надо только закидывать (бэкапить) файлы с других дисков внутри NAS

Если в целом криптоконтейнеры трогаем чтолько в консоли, можно даже удалить плагин Encryption.

=== Закрыть криптоконтейнер ===

Можно дежурно проверить, какие файловые системы примонтированы в систему:

''mount''

Среди всех точек монтирования вижу нужную:

''/dev/mapper/enc_wd_red_6tb on /srv/dev-disk-by-uuid-0006tb22-r34f-q3r4-6b78-pc45fb2ks921 type ext4 (rw,relatime)''

Отмонтировать:

''sudo umount /dev/mapper/enc_wd_red_6tb''

Закрыть:

''sudo cryptsetup close enc_wd_red_6tb''

===== Сделать бэкап LUKS header =====

LUKS header — это главная метка и структура шифрования контейнера, где хранятся:

* ключи шифрования (master key, ключи пользователей),
* параметры шифрования (алгоритм, размер блока),
* метаданные тома.

Без него доступ к данным потерян. Если заголовок повреждён (например, из-за сбоя диска или случайного dd), то восстановить содержимое невозможно, даже если пароль известен. Поэтому бэкап LUKS header — это //отдельный файл//, который можно восстановить при проблемах, не трогая сам зашифрованный том.

1. ''Storage > Encryption''
2. Выбрать диск
3. Recovery
4. Выбрать Backup-header
5. Сохранить его, бо в будущем может понадобиться.

Можно сделать то же самое вручную:

''sudo cryptsetup luksHeaderBackup /dev/sdb2 --header-backup-file /etc/keys/enc_wd_red_6tb-header.bak''

* ''/dev/sdb2'' — зашифрованный раздел
* ''/~/enc_wd_red_6tb-header.bak'' — файл бэкапа, хранить на другом диске, который лежит в утке, которая лежит в дудке. Этот файл содержит все ключи LUKS, если кто-то его получит — сможет расшифровать зашифрованный диск. Размер таких файлов  <2 MB, поэтому хранить его можно где угодно, лишь бы подальше от NAS.

//Вернуться//: [[Добавить HDD]]
